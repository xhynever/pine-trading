//@version=5
library("VegasChannelLib")

// ============= EMA计算 =============
export f_calculate_emas(int len12, int len144, int len156, int len565, int len676) =>
    [ta.ema(close, len12), ta.ema(close, len144), ta.ema(close, len156), ta.ema(close, len565), ta.ema(close, len676)]

// ============= 空头趋势检测 =============
export f_is_downtrend(float ema12, float ema144, float ema156, float ema565, float ema676) =>
    ema12 < math.min(ema144, ema156) and math.min(ema144, ema156) < math.min(ema565, ema676)

// ============= 循环队列 =============
export type CircularQueue
    array<float> data
    int capacity
    int head
    int size

export f_create_queue(int capacity) =>
    queue = CircularQueue.new()
    queue.data := array.new<float>(capacity)
    queue.capacity := capacity
    queue.head := 0
    queue.size := 0
    queue

export f_queue_push(CircularQueue queue, float value) =>
    if queue.size < queue.capacity
        array.set(queue.data, queue.size, value)
        queue.size += 1
    else
        array.set(queue.data, queue.head, value)
        queue.head := (queue.head + 1) % queue.capacity

export f_queue_get(CircularQueue queue, int index) =>
    if index < 0 or index >= queue.size
        0.0
    else
        idx = (queue.head + index) % queue.capacity
        array.get(queue.data, idx)

export f_queue_size(CircularQueue queue) =>
    queue.size

export f_queue_max(CircularQueue queue) =>
    max_val = 0.0
    for i = 0 to queue.size - 1
        val = f_queue_get(queue, i)
        if val > max_val
            max_val := val
    max_val

export f_queue_min(CircularQueue queue) =>
    min_val = 999999.0
    for i = 0 to queue.size - 1
        val = f_queue_get(queue, i)
        if val < min_val
            min_val := val
    min_val

// ============= 斜率计算（线性回归） =============
export f_calculate_slope(float source, int period) =>
    if bar_index < period
        0.0
    else
        x_sum = 0.0
        y_sum = 0.0
        xy_sum = 0.0
        x2_sum = 0.0
        for i = 0 to period - 1
            x = float(i)
            y = source[i]
            x_sum += x
            y_sum += y
            xy_sum += x * y
            x2_sum += x * x
        n = float(period)
        numerator = n * xy_sum - x_sum * y_sum
        denominator = n * x2_sum - x_sum * x_sum
        slope = denominator != 0 ? numerator / denominator : 0.0
        math.atan(slope) * 180.0 / math.pi

// ============= 斜率判断 =============
export f_slope_below_threshold(float slope, float threshold) =>
    math.abs(slope) < threshold

export f_slope_above_threshold(float slope, float threshold) =>
    slope > threshold

// ============= 价格记录 =============
export f_record_price(float price, float ema12, array<float> highprice_arr, array<float> lowprice_arr) =>
    if price > ema12
        array.push(highprice_arr, price)
    else
        array.push(lowprice_arr, price)

// ============= 移动止损计算 =============
export f_calculate_trailing_stop(bool is_long, float entry_price, array<float> highprice_arr, array<float> lowprice_arr) =>
    total_count = array.size(highprice_arr) + array.size(lowprice_arr)
    if total_count <= 8
        entry_price
    else
        if is_long
            if array.size(highprice_arr) < array.size(lowprice_arr)
                entry_price
            else
                lowprice_sum = 0.0
                for i = 0 to array.size(lowprice_arr) - 1
                    lowprice_sum += array.get(lowprice_arr, i)
                lowprice_sum / array.size(lowprice_arr)
        else
            if array.size(highprice_arr) > array.size(lowprice_arr)
                entry_price
            else
                highprice_sum = 0.0
                for i = 0 to array.size(highprice_arr) - 1
                    highprice_sum += array.get(highprice_arr, i)
                highprice_sum / array.size(highprice_arr)

// ============= 止盈计算 =============
export f_get_take_profit_levels(float entry_price, bool is_long) =>
    if is_long
        [entry_price * 1.10, entry_price * 1.15, entry_price * 1.25]
    else
        [entry_price * 0.90, entry_price * 0.85, entry_price * 0.75]

// ============= 止损计算 =============
export f_get_stop_loss(float entry_price, bool is_long, float sl_percent=5) =>
    if is_long
        entry_price * (1 - sl_percent / 100)
    else
        entry_price * (1 + sl_percent / 100)
